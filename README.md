# 晓音实时HTTP适配 v0.0.1_alpha
适用于晓音实时http组件的适配，可以同步将结果返回给用户。
基本数据流程如下：
语音流：用户请求->本适配->晓音实时HTTP组件->引擎
识别文本：引擎->晓音实时HTTP组件（目前需要其在配置文件内填入本适配的地址）->本适配->用户

实时语音转写适配。包含语音会话并发管理、语音帧缓存等模块，实现实时引擎复用。

最后一个字段会尝试从redis中读取100次，读取100s后结束，取消计时，将结果返回
## 1. 静音检测
静音检测 包含 自适应静音阈值调整 和 断句 两个部分
### 1.1 自适应
当新的语音流进入时，默认使用-95dB作为静音判断的阈值。

### 1.2 检测范围
若无有效的非静音则判该帧为静音。

若该帧无有效的静音，则判该帧为非静音。

若同时检测到有效的非静音和有效的静音
- 若前一帧是非静音，则先寻找第一个 有效静音段，在之后再寻找是否有 有效非静音段。在静音段中间处分割，间隔约500ms分别先后送入转写模块。间隔500ms是为了给出引擎返回转写结果和断开的时间，减少缓存的使用。
- 若前一帧是 静音，则先寻找第一个 有效非静音段 后再寻找该 有效非静音 后是否有 有效静音，整帧送入转写模块。若本帧包含 有效静音，且有效静音持续到本帧结束，再送入空语音以获取转写结果。

## 2. 锁逻辑
用到锁的地方有：语音流状态的获取和写入。 暂时不在应用并发的加减，引擎并发的加减上做

### 2.1. 应用并发的加减
在检查/增加或删去应用并发前会加锁，完成检查或增删后解锁

### 2.2. 引擎并发的加减
在检查/增加或删去引擎并发前会加锁，完成检查或增删后解锁； 先增加并发数后再尝试获取引擎许可，若获取失败则会减去并发数。 在断开引擎连接后才会删去引擎并发数。 缓存在周期性检查、获取引擎资源时也使用该锁

### 2.3. 语音流状态的获取与写入
在获取语音流状态前加锁，在写入语音流状态后解锁，目的是为了保证一个语音流每秒的音频按顺序处理。 因目前在语音流初始化后，对新进入的一帧处理需要先读取语音流状态，在触发最后一个引擎动作后写入语音流状态。
（注意：仅当引擎响应延迟良好的时候，否则需要在缓存处理部分sendCache2Engine延迟释放锁）

### 2.4. 返回文字流状态的获取与写入
在获取文字流写入redis状态前加锁，在写入文字流状态后解锁，暂时缓存返回文字流，目的是为了保证下一个请求来时，返回相关的文字。根据状态返回响应的文字。



## 3. 多租户多引擎
可接入对接多个不同引擎（但目前请求格式不可变更）。 在实时ASR适配中，一个appId只能对应一个engineId，一个engineId可以对接多个appId。 通过修改配置文件可自动不停机生效。

### 3.1. audioStatus
在分发里指整个语音流的起始 中间 结束状态，而在引擎指一个句子的起始 中间 结束状态。故本代码中仅接受请求的接口中使用前者的含义。

### 3.2 并发锁
目前并发控制使用不公平锁，且效率不高（如同时并发100个请求，1个进去了后，剩下99个等10ms才能进下一个）。 高并发(多redis读写，估测至少1000并发)简易优化方案如下：redis
list做消息队列，插入队列时会加查询锁但不加锁，并定时加锁（如50ms）批量送入并发。\
另外，目前生产环境同一时间仅使用单台redis读写，不需要并发锁。

#### 4.1 接收方服务器故障导致发送转写结果失败
网络异常或接收方关闭了接收端口。


#### 4.3 引擎问题

##### 4.3.1 引擎性能问题
目前设置的转写结果返回超时时间是10s，正常情况下很难发生超时。科大引擎性能正常的情况下最长转写时间应该在3秒左右（5秒缓存时），自研引擎在2秒左右。若出现超时或较长转写延迟的，请查询引擎日志，是否引擎转写过慢。
若有引擎过慢可尝试将其迁移到其他物理机/与其他正常的引擎交换位置（需要与云资源联系），或减少该物理机的并发上限（需修改组件配置并重启组件）。

##### 4.3.2 引擎转写问题
因我们静音检测不能将长噪音与人声区分，一些噪音被送入引擎后，引擎会返回错误（经组件修改为空），适配相关的warn属于正常现象。

#### 4.4 组件问题
目前组件在启动后，无关等待时长，当我方发送ssb请求时都会有超时（800ms超时）。目前本适配会在0点无并发时或发生引擎license过期时自动校准并发数。组件日志不会在分裂后重置大小，会越来越大。 组件之后需要做热备+浮动地址。


## TODO
将热词以及返回地址在本适配中加上
